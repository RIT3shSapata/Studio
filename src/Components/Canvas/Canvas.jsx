import React, { useEffect, useRef } from 'react';

//to prevent fuzzy rendering
const getPixelRatio = (context) => {
    var backingStore =
        context.backingStorePixelRatio ||
        context.webkitBackingStorePixelRatio ||
        context.mozBackingStorePixelRatio ||
        context.msBackingStorePixelRatio ||
        context.oBackingStorePixelRatio ||
        context.backingStorePixelRatio ||
        1;

    return (window.devicePixelRatio || 1) / backingStore;
};
const Canvas = ({ code, run, setRun }) => {
    const canvasRef = useRef(null);
    const renderOnce = useRef(false);
    //to store the id generated by requestAnimationFrame
    const requestIDRef = useRef(null);
    const i = useRef(0);
    const j = useRef(0);

    useEffect(() => {
        if (renderOnce.current) return;
        const canvas = canvasRef.current;
        const context = canvas.getContext('2d');

        //to prevent fuzzy rendering
        let ratio = getPixelRatio(context);
        let width = getComputedStyle(canvas)
            .getPropertyValue('width')
            .slice(0, -2);
        let height = getComputedStyle(canvas)
            .getPropertyValue('height')
            .slice(0, -2);

        canvas.width = width * ratio;
        canvas.height = height * ratio;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;

        i.current = canvas.width / 5;
        j.current = canvas.height / 5;

        const render = () => {
            requestIDRef.current = requestAnimationFrame(render);
            // console.log('render');
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.beginPath();
            context.arc(
                i.current,
                j.current,
                canvas.width / 20,
                0,
                2 * Math.PI
            );
            context.fill();
            // i.current = i.current + 10;
        };
        render();

        return () => {
            cancelAnimationFrame(requestIDRef.current);
        };
    }, []);

    const handleDown = () => {
        return new Promise((resolve, reject) => {
            const canvas = canvasRef.current;
            const context = canvas.getContext('2d');
            const target = j.current + 100;
            const down = () => {
                if (j.current > target) {
                    resolve();
                    return;
                }
                requestIDRef.current = requestAnimationFrame(down);
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.arc(
                    i.current,
                    j.current,
                    canvas.width / 20,
                    0,
                    2 * Math.PI
                );
                context.fill();
                j.current = j.current + 1;
            };
            down();
        });
    };
    const handleUp = () => {
        return new Promise((resolve, reject) => {
            const canvas = canvasRef.current;
            const context = canvas.getContext('2d');
            const target = j.current - 100;
            const up = () => {
                if (j.current < target) {
                    resolve();
                    return;
                }
                requestIDRef.current = requestAnimationFrame(up);
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.arc(
                    i.current,
                    j.current,
                    canvas.width / 20,
                    0,
                    2 * Math.PI
                );
                context.fill();
                j.current = j.current - 1;
            };
            up();
        });
    };
    const handleLeft = () => {
        return new Promise((resolve, reject) => {
            const canvas = canvasRef.current;
            const context = canvas.getContext('2d');
            const target = i.current - 100;
            const left = () => {
                if (i.current < target) {
                    resolve();
                    return;
                }
                requestIDRef.current = requestAnimationFrame(left);
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.arc(
                    i.current,
                    j.current,
                    canvas.width / 20,
                    0,
                    2 * Math.PI
                );
                context.fill();
                i.current = i.current - 1;
            };
            left();
        });
    };
    const handleRight = () => {
        return new Promise((resolve, reject) => {
            const canvas = canvasRef.current;
            const context = canvas.getContext('2d');
            const target = i.current + 100;
            const right = () => {
                if (i.current == target) {
                    resolve();
                    return;
                }
                requestIDRef.current = requestAnimationFrame(right);
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.beginPath();
                context.arc(
                    i.current,
                    j.current,
                    canvas.width / 20,
                    0,
                    2 * Math.PI
                );
                context.fill();
                i.current = i.current + 1;
            };
            right();
        });
    };

    useEffect(() => {
        if (run) {
            console.log(code.current);
            const instructions = code.current.split('\n');
            if (instructions.includes('not_connected')) {
                console.log('connect all blocks');
                alert('connect all blocks');
                code.current = '';
            }
            const animate = async () => {
                for (var idx = 0; idx < instructions.length; idx++) {
                    var instruction = instructions[idx];
                    switch (instruction) {
                        case 'move_up':
                            await handleUp();
                            break;
                        case 'move_down':
                            await handleDown();
                            break;
                        case 'move_left':
                            await handleLeft();
                            break;
                        case 'move_right':
                            await handleRight();
                            break;
                        default:
                            console.log('maze complete');
                    }
                }
            };
            // console.log(ins);
            animate();
            setRun(false);
        }
    }, [code, run]);
    return (
        <div className="p-5 flex justify-around w-3/4 h-full">
            <canvas
                ref={canvasRef}
                className="w-full h-full border-8 border-slate-900"
                id="canvas"></canvas>
        </div>
    );
};

export default Canvas;
